// barebones of a fsm, if you are doing timer stuff feel free to edit the increase a bit, Im not sure what i should add to make it work :(
// This is the main file you will be editing for testing FSM modules
module chopsticks_fsm (
    input clk,  // clock
    input rst,  // reset
    input decrease_timer,
    input regfile_rd2[32],
    input p1l_button,
    input p1r_button,
    input p2r_button,
    input p2l_button,
    input p1split,
    input p2split,
    
    output alufn[6],
    output asel[2],
    output bsel[2],
    output wdsel[2],
    output regfile_wa[4],
    output regfile_ra1[4],
    output regfile_ra2[4],
    output regfile_we,
    output debug[4]
) {
    //use this to list the states you are testing for your module
    enum ChopSticksStates{
        //IMPLEMENTING ATTACK SELF / OPPONENT 
        START,
        BRANCHPLAYER,
        
        //where the calculation
        ATK_CALC_RESULT,
        
        // player 1 left hand
        ATK_CHECK_ATTACKEDHAND_P1L, // CHECK IF P1L WAS ATTACKED
        ATK_BRANCH_P1L, // IDK, TO BRANCH if its P1L or not
        ATK_P1L_5ORLESS, // CHECK IF HAND IS DEAD OR ALIVE, includes update in the else
        ATK_REMOVE_P1LAVAIL, // IF DEAD
        ATK_P1L_DEAD_OR_ALIVE,
        
        // player 1 right hand
        ATK_CHECK_ATTACKEDHAND_P1R, // CHECK IF P1R WAS ATTACKED
        ATK_BRANCH_P1R, // IDK, TO BRANCH if its P1R or not
        ATK_P1R_5ORLESS, // CHECK IF HAND IS DEAD OR ALIVE, includes update in the else
        ATK_REMOVE_P1RAVAIL, //  IF DEAD
        ATK_P1R_DEAD_OR_ALIVE,
        
        // player 2 left hand
        ATK_CHECK_ATTACKEDHAND_P2L, // CHECK IF P2L WAS ATTACKED
        ATK_BRANCH_P2L, // IDK, TO BRANCH if its P2L or not
        ATK_P2L_5ORLESS, // CHECK IF HAND IS DEAD OR ALIVE, includes update in the else
        ATK_REMOVE_P2LAVAIL, //  IF DEAD
        ATK_P2L_DEAD_OR_ALIVE,
        
        // player 2 right hand
        //CHECK_ATTACKEDHAND_P2R, // CHECK IF P2R WAS ATTACKED, REMOVED TO FOLLOW THE FSM
        //BRANCH_P2R, // IDK, TO BRANCH if its P2R or not,, changed to dead or alive
        ATK_P2R_5ORLESS, // CHECK IF HAND IS DEAD OR ALIVE, includes update in the else
        ATK_REMOVE_P2RAVAIL, //  IF DEAD
        ATK_P2R_DEAD_OR_ALIVE,
        
        // checker 
        BRANCHP1LAVAIL
        
    }
    
    
    // stores the states in a dff
    .clk(clk){
        .rst(rst){
    dff game_fsm[$width(ChopSticksStates)](#INIT(ChopSticksStates.START))
        }
    }
    always {
        //default control signal setings
        alufn = 0
        asel = 0
        bsel = 0
        wdsel = 0
        regfile_wa = d9
        regfile_we = 0
        regfile_ra1 = d0
        regfile_ra2 = d0
        debug = b0000
        
        game_fsm.d = game_fsm.q
        if(rst){
            game_fsm.d = ChopSticksStates.START
        }
        else{
            //this is where you start coding out your states
            case(game_fsm.q){
                ChopSticksStates.START:
                regfile_ra2 = d12
                    if(~|regfile_rd2){ // we start when temp 4 == 0, last red bubble of checking attack portion
                        if(p1r_button){
                        game_fsm.d = ChopSticksStates.ATK_CALC_RESULT
                        }
                    }
                
                
                ChopSticksStates.ATK_CALC_RESULT:
                    alufn = b000000 // ADD
                    asel = b00
                    bsel = b00
                    wdsel = 0
                    regfile_we = 1
                    regfile_wa = d10 // write to temp 2
                    regfile_ra1 = d10 // what is in temp 2, shld be attacked hand
                    regfile_ra2 = d11 // whatever is in temp 3, should be attacking hand
                    debug = b0001
                    game_fsm.d = ChopSticksStates.ATK_CHECK_ATTACKEDHAND_P1L
                
                
                // CHECKING IF IS ATTACKED HAND IS PLAYER 1 LEFT 
                
                
                
                
                
                ChopSticksStates.ATK_CHECK_ATTACKEDHAND_P1L:
                    alufn = b110011 // CMPEQ
                    asel = b00
                    bsel = b01 // provides a value of 0
                    wdsel = 0
                    regfile_we = 1
                    regfile_wa = d12 // write to temp 4
                    regfile_ra1 = d9  // whatever is in temp 1, which shld be address of the attacked hand
                    //regfile_ra2 = d00 , dont need ra2 cuz bsel is not 0 
                    debug = b0010
                    game_fsm.d = ChopSticksStates.ATK_BRANCH_P1L
                
                
                ChopSticksStates.ATK_BRANCH_P1L:
                    regfile_ra2 = d12 //checks R12 checks temp 4
                    if(|regfile_rd2){ //  CHECKS IF TEMP 4 == 1, which means address in temp 4 is 0, P1L correct
                        game_fsm.d = ChopSticksStates.ATK_P1L_DEAD_OR_ALIVE
                    }
                    else{ // if temp4==0, means address in temp4 is not 0, so we check other addresses 
                        game_fsm.d = ChopSticksStates.ATK_CHECK_ATTACKEDHAND_P1R
                    }
                
                
                ChopSticksStates.ATK_P1L_DEAD_OR_ALIVE:
                    // checking 5 <= hand value, returns 1 when hand >=5 (dead)
                        alufn = b110111 // CMPLE, 
                        asel = b10 // provides a value of 5
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d12 // write to temp 4
                        //regfile_ra1 = not needed
                        regfile_ra2 = d10 // temp 2, should be result of attacked hand  
                        debug = b0011
                    game_fsm.d = ChopSticksStates.ATK_P1L_5ORLESS
                
                
                ChopSticksStates.ATK_P1L_5ORLESS:
                    regfile_ra2 = d12 //checks temp4 
                    if(|regfile_rd2){ //  if temp4==1, hand is dead
                        // set P1L score to 0
                        alufn = b011100 //  "B"
                        //asel =  not needed
                        bsel = b01 // provides a value of 0 at the bsel
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d0 // write to register 0
                        //regfile_ra1 = not needed
                        //regfile_ra2 = not needed  
                        debug = b0001
                        game_fsm.d = ChopSticksStates.ATK_REMOVE_P1LAVAIL
                    }
                    else{ // if temp4==0, hand is alive 
                        // UPDATE P1L score to whatever is in temp 2
                        alufn = b011010 // "A"
                        asel = b00 
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d0 // write to address reg 0, which is address of P1L content 
                        regfile_ra1 = d10 // temp2, should contain the result of the attacked hand
                        //regfile_ra2 not needed 
                        debug = b0100
                        game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating hand
                    }
                
                
                ChopSticksStates.ATK_REMOVE_P1LAVAIL:
                    // set P1LAVAIL to 0 
                    alufn = b011100 // "B"
                    bsel = b01 // provides a value of 0 
                    wdsel = 0
                    regfile_wa = d4 // write to register 4, dictates player 1 left availability to 0 
                    regfile_we = 1
                    debug = b1100
                    game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating avail
                
                
                // CHECKING IF ATTACKED HAND IS PLAYER 1 right 
                
                
                ChopSticksStates.ATK_CHECK_ATTACKEDHAND_P1R:
                    // checks if the attacked hand has address of 1
                    alufn = b110011 // CMPEQ
                    asel = b00
                    bsel = b10 // provides a value of 1
                    wdsel = 0
                    regfile_we = 1
                    regfile_wa = d12 // write to temp 4
                    regfile_ra1 = d09 // whatever is in temp 1, which shld be address of the attacked hand
                    //regfile_ra2 = d00 , dont need ra2 cuz bsel is not 0 
                    debug = b0101
                    game_fsm.d = ChopSticksStates.ATK_BRANCH_P1R
                
                
                ChopSticksStates.ATK_BRANCH_P1R:
                    regfile_ra2 = d12 //checks temp4
                    if(|regfile_rd2){ //  CHECKS IF TEMP 4 == 1, which means address in temp 4 is 1, P1R correct
                        game_fsm.d = ChopSticksStates.ATK_P1R_DEAD_OR_ALIVE
                    }
                    else{ // if temp4==0, means address in temp4 is not 1, so we check other addresses 
                        game_fsm.d = ChopSticksStates.ATK_CHECK_ATTACKEDHAND_P2L
                    }
                
                
                ChopSticksStates.ATK_P1R_DEAD_OR_ALIVE:
                    // checking 5 <= hand value, returns 1 when hand >=5 (dead)
                        alufn = b110111 // CMPLE, 
                        asel = b10 // provides a value of 5
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d12 // write to temp 4
                        //regfile_ra1 = not needed
                        regfile_ra2 = d10 // temp 2, should be result of attacked hand  
                        debug = b0011
                    game_fsm.d = ChopSticksStates.ATK_P1R_5ORLESS
                
                
                ChopSticksStates.ATK_P1R_5ORLESS:
                    regfile_ra2 = d12 //checks temp4 
                    if(|regfile_rd2){ //  if temp4==1, hand is dead
                        // set P1R score to 0
                        alufn = b011100 //  "B"
                        //asel =  not needed
                        bsel = b01 // provides a value of 0 at the bsel
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d1 // write to register 1, for P1R
                        //regfile_ra1 = not needed
                        //regfile_ra2 = not needed  
                        debug = b0000
                        game_fsm.d = ChopSticksStates.ATK_REMOVE_P1RAVAIL
                    }
                    else{ // if temp4==0, hand is alive 
                        // UPDATE P1R score to whatever is in temp 2
                        alufn = b011010 // "A"
                        asel = b00 
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d1 // write to address reg 1, which is address of P1R content 
                        regfile_ra1 = d10 // temp2, should contain the result of the attacked hand
                        //regfile_ra2 not needed 
                        debug = b1000
                        game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating hand
                    }
                
                
                ChopSticksStates.ATK_REMOVE_P1RAVAIL:
                    // set P1RAVAIL to 0 
                    alufn = b011100 // "B"
                    bsel = b01 // provides a value of 0 
                    wdsel = 0
                    regfile_wa = d5 // write to register 5, dictates player 1 right availability to 0 
                    regfile_we = 1
                    debug = b1000
                    game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating avail
                
                
                // CHECKING IF ATTACKED HAND IS PLAYER 2 LEFT 
                
                
                ChopSticksStates.ATK_CHECK_ATTACKEDHAND_P2L:
                    // checks if the attacked hand has address of 2
                    alufn = b110011 // CMPEQ
                    asel = b00
                    bsel = b11 // provides a value of 2
                    wdsel = 0
                    regfile_we = 1
                    regfile_wa = d12 // write to temp 4
                    regfile_ra1 = d9 // whatever is in temp 1, which shld be address of the attacked hand
                    //regfile_ra2 = d00 , dont need ra2 cuz bsel is not 0 
                    debug = b1100
                    game_fsm.d = ChopSticksStates.ATK_BRANCH_P2L
                
                
                ChopSticksStates.ATK_BRANCH_P2L:
                    regfile_ra2 = d12 //checks temp4
                    if(|regfile_rd2){ //  CHECKS IF TEMP 4 == 2, which means address in temp 4 is 2, P2L correct
                        game_fsm.d = ChopSticksStates.ATK_P2L_DEAD_OR_ALIVE
                    }
                    else{ // if temp4==0, means address in temp4 is not 1, so we check other addresses 
                        game_fsm.d = ChopSticksStates.ATK_P2R_DEAD_OR_ALIVE 
                    }
                
                
                ChopSticksStates.ATK_P2L_DEAD_OR_ALIVE:
                    // checking 5 <= hand value, returns 1 when hand >=5 (dead)
                        alufn = b110111 // CMPLE, 
                        asel = b10 // provides a value of 5
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d12 // write to temp 4
                        //regfile_ra1 = not needed
                        regfile_ra2 = d10 // temp 2, should be result of attacked hand  
                        debug = b0011
                    game_fsm.d = ChopSticksStates.ATK_P2L_5ORLESS
                
                
                ChopSticksStates.ATK_P2L_5ORLESS:
                    regfile_ra2 = d12 //checks temp4 
                    if(|regfile_rd2){ //  if temp4==1, hand is dead
                        // set P2L score to 0
                        alufn = b011100 //  "B"
                        //asel =  not needed
                        bsel = b01 // provides a value of 0 at the bsel
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d2 // write to register 2, for P2L
                        //regfile_ra1 = not needed
                        //regfile_ra2 = not needed  
                        debug = b1000
                        game_fsm.d = ChopSticksStates.ATK_REMOVE_P2LAVAIL
                    }
                    else{ // if temp4==0, hand is alive 
                        // UPDATE P2L score to whatever is in temp 2
                        alufn = b011010 // "A"
                        asel = b00 
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d2 // write to address reg 2, which is address of P2L content 
                        regfile_ra1 = d10 // temp2, should contain the result of the attacked hand
                        //regfile_ra2 not needed 
                        debug = b1000
                        game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating hand
                    }
                
                
                ChopSticksStates.ATK_REMOVE_P2LAVAIL:
                    // set P2LAVAIL to 0 
                    alufn = b011100 // "B"
                    bsel = b01 // provides a value of 0 
                    wdsel = 0
                    regfile_wa = d6 // write to register 6, dictates player 2 Left availability to 0 
                    regfile_we = 1
                    debug = b1000
                    game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating avail
                
                
                
                // CHECKING IF ATTACKED HAND IS PLAYER 2 RIGHT 
                
                
                ChopSticksStates.ATK_P2R_DEAD_OR_ALIVE:
                    // checking 5 <= hand value, returns 1 when hand >=5 (dead)
                        alufn = b110111 // CMPLE, 
                        asel = b10 // provides a value of 5
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d12 // write to temp 4
                        //regfile_ra1 = not needed
                        regfile_ra2 = d10 // temp 2, should be result of attacked hand  
                        debug = b1000
                        game_fsm.d = ChopSticksStates.ATK_P2R_5ORLESS
                
                
                ChopSticksStates.ATK_P2R_5ORLESS:
                    regfile_ra2 = d12 //checks temp4 
                    if(|regfile_rd2){ //  if temp4==1, hand is dead
                        // set P2R score to 0
                        alufn = b011100 //  "B"
                        //asel =  not needed
                        bsel = b01 // provides a value of 0 at the bsel
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d3 // write to register 2, for P2R
                        //regfile_ra1 = not needed
                        //regfile_ra2 = not needed  
                        debug = b1000
                        game_fsm.d = ChopSticksStates.ATK_REMOVE_P2RAVAIL
                    }
                    else{ // if temp4==0, hand is alive 
                        // UPDATE P2R score to whatever is in temp 2
                        alufn = b011010 // "A"
                        asel = b00 
                        bsel = b00 
                        wdsel = 0
                        regfile_we = 1
                        regfile_wa = d3 // write to address reg 3, which is address of P2R content 
                        regfile_ra1 = d10 // temp2, should contain the result of the attacked hand
                        //regfile_ra2 not needed 
                        debug = b1000
                        game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating hand
                    }
                
                
                ChopSticksStates.ATK_REMOVE_P2RAVAIL:
                    // set P2RAVAIL to 0 
                    alufn = b011100 // "B"
                    bsel = b01 // provides a value of 0 
                    wdsel = 0
                    regfile_wa = d7 // write to register 7, dictates player 2 Right availability to 0 
                    regfile_we = 1
                    debug = b1000
                    game_fsm.d = ChopSticksStates.BRANCHP1LAVAIL // goes to end game checker after updating avail
                
                
                
                
                // replace with seans end game checker one !!!!
                ChopSticksStates.BRANCHP1LAVAIL: //just added for testing purposes
                    // set temp4 to 0 so it stops looping 
                    alufn = b011100 // "B"
                    bsel = b10 // provides a value of 1
                    wdsel = 0
                    regfile_wa = b1100 // write to register 12, dictates temp4 to 1
                    regfile_we = 1                
                debug = b1111
                game_fsm.d = ChopSticksStates.START
                                                
            }
        }
        
    }
}

























































































