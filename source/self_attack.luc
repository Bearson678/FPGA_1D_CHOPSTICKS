module self_attack #(
    
    OWNLSADDR ~ 0 : OWNLSADDR == 0 || OWNLSADDR == 2,
    OWNRSADDR ~ 1 : OWNRSADDR == 1 || OWNRSADDR == 3,
    OWNLAADDR ~ 4 : OWNLAADDR == 4 || OWNLAADDR == 6, 
    OWNRAADDR ~ 5 : OWNRAADDR == 5 || OWNRAADDR == 7
)(
    input clk,  // clock
    input rst,  // reset
    input regfile_rd2[32],
    input start_selfatk[1],
    output alufn[6],
    output asel[2],
    output bsel[2],
    output wdsel[2],
    output regfile_wa[4],
    output regfile_ra1[4],
    output regfile_ra2[4],
    output regfile_we,
    output debug[4]
) {
    enum SelfAttackStates{
        //IMPLEMENTING THE TIMER MODULE
        IDLE,
        
        ILLEGAL,
        
        CONTINUE
    
    }
    
    .clk(clk){
        .rst(rst){
    dff game_fsm[$width(SelfAttackStates)](#INIT(SelfAttackStates.IDLE))
        }
    }
    
    always {
        //default control signal setings
        alufn = 0
        asel = 0
        bsel = 0
        wdsel = 0
        regfile_wa = 0
        regfile_we = 0
        regfile_ra1 = d0
        regfile_ra2 = d0
        debug = b0000
        game_fsm.d = game_fsm.q
        
        if(rst){
            game_fsm.d = SelfAttackStates.IDLE
        }
        else{
            case(game_fsm.q){
                SelfAttackStates.IDLE:
                if(start_selfatk) {
                        game_fsm.d = SelfAttackStates.IDLE // placeholder, should go next state
                    }
                
            }
    }
 }
}
